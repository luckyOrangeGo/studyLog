# Docker Swarm learn

## 问题提出

- 我们如何实现容器生命周期的自动化？
- 我们怎样才能轻松地扩展out/in/up/down？
- 我们如何确保我们的容器在失败时重新创建？
- 我们如何在没有停机的情况下更换容器(蓝色/绿色部署)？
- 我们如何控制/追踪容器的起始位置？
- 我们如何创建跨节点虚拟网络？
- 我们如何才能确保只有受信任的服务器运行我们的容器？
- 我们如何存储秘密，密钥和密码并将它们送到正确的容器（并且只有那个容器）？

## Raft

>Understandable Distributed Consensus

可理解的分布式共识 [Raft](http://thesecretlivesofdata.com/raft/)

那么什么是分布式共识？我们从一个例子开始......

### 分布式共识

假设我们有一个单节点系统，对于这个例子，你可以将我们的**节点**看作是存储单个值的数据库服务器。我们也有一个**客户端**可以向服务器发送一个值。就一个节点而言，就该价值达成一致或达成共识很容易。但是，如果我们有多个节点，我们如何达成共识？这就是*分布式共识*的问题。

***Raft***是实施分布式共识的协议。我们来看一下它的工作原理。

### 领导者选举

一个节点可以处于三种状态之一：

- The Follower state 追随者状态
- The Candidate state 候选人状态
- The Leader state 领导者状态

我们所有的节点都是从追随者状态开始的。如果追随者没有听到领导者的消息，他们可以成为候选人。候选人然后请求其他节点的投票。节点将回复他们的投票。如果候选人从大多数节点获得投票，他将成为领导者。这个过程被称为*领导者选举*。

现在系统的**所有变化都通过领导者**。每个更改都添加为领导者节点日志中的条目。

如果日志条目当前未提交，它不会更新**领导者节点**的值。要提交条目，**领导者节点**首先将其复制到**跟随者节点上**，然后领导等待，直到大多数跟随者节点已经写入该条目。

该条目现在在领导者节点上提交并且节点状态为“5”（大多数）。领导者随后通知追随者该条目已经落实。该集群现在已经就系统状态达成共识。

这个过程称为*日志复制*。

#### 领袖选举

在**Raft**中，有两个控制选举的超时设置。

首先是**选举超时**。

选举超时是一个追随者在成为候选人之前等待的时间。选举超时被随机分配在150ms和300ms之间。选举超时后，追随者成为候选人，并开始新的*选举期限*...为自己投票...并将*请求投票*消息发送给其他节点。如果接收节点尚未在此期间投票，那么它会为候选人投票...并且该节点重置其选举超时。

一旦候选人A获得多数票，它就成为领导者。领导者A开始发送*Append Entrie 追加条目*消息给其追随者B,C。

这些消息以**心跳超时**指定的间隔发送。追随者B,C然后回应每个*Append Entries 追加条目*消息。

这个选举任期将持续到跟随者B,C停止接受心跳并成为候选人。

我们停止领导人节点A，就会开始*重新选举*。

要求得票的多数保证每个任期只能选一个领导人。如果两个节点同时成为候选人，则可能发生分裂投票。让我们来看看一个分割投票的例子...

##### 分割投票

两个节点同时开始选举......并且每个在另一个之前到达单个跟随者节点。现在每个候选人有2票，并且不能再收到这个任期。节点C在第5期获得多数票，因此成为领导者。

### 日志复制

一旦选出了领导者，我们需要将对我们系统的所有更改复制到所有节点。这是通过使用被用于心跳追加条目消息来完成。

首先，客户端向领导者发送变更值为“5”。这个改变被附加到领导者的日志中，然后在下一次心跳中将变化发送给追随者。一旦大多数追随者承认它，领导者就会转换到下一个条目，并将响应发送给客户端。

面对网络分区，Raft甚至可以保持一致。

让我们添加一个分区，将A和B从C，D和E中分离出来。由于我们的分割，我们现在有两个不同的领导者。

A, B(领导者) || C(领导者), D, E

让我们添加另一个客户端，并尝试更新两位领导者。

一个客户端会尝试将节点B的值设置为“3”。领导者节点B不能复制到大多数，所以它的日志条目保持未提交。另一个客户端将尝试将领导者节点C的值设置为“8”。这将成功，因为它可以复制到大多数。

现在我们来修复网络分区。

节点B(期限1)将看到较高的选举期限-节点C(期限2)，并下台。节点A和B都将回滚未提交的条目并匹配新领导的日志。我们的日志现在在整个集群中保持一致。

结束
